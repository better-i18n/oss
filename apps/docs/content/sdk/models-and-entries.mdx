---
title: Models & Entries
description: Query content with the chainable from() API
icon: FileText
---

Better i18n's headless CMS organizes content into **models** and **entries**. Models define the structure (like a database table), and entries are the individual pieces of content (like rows). The SDK exposes a Supabase-style chainable query builder that makes it easy to filter, sort, paginate, and expand content in one readable chain.

## Content Models

A content model defines the shape of your content. Each model has a slug, display name, kind, and optional custom fields.

```typescript
const models = await client.getModels();
```

**Response:**

```json
[
  {
    "slug": "blog-posts",
    "displayName": "Blog Posts",
    "description": "Company blog articles",
    "kind": "collection",
    "entryCount": 24
  },
  {
    "slug": "changelog",
    "displayName": "Changelog",
    "description": "Product updates and releases",
    "kind": "collection",
    "entryCount": 8
  }
]
```

**Model kinds:**
- `collection` — Multiple entries (blog posts, changelog, FAQ)
- `single` — One entry (about page, homepage content)

## Query Builder

`client.from(modelSlug)` starts a chainable query builder. Every method returns a **new immutable builder** — calls never mutate the original — so you can safely branch and reuse base queries.

The builder is **thenable**: `await` it directly to execute the query. You do not need to call a separate `.execute()` or `.get()` method.

```typescript
const { data, error, total, hasMore } = await client
  .from("blog-posts")
  .eq("status", "published")
  .order("publishedAt", { ascending: false })
  .limit(10);
```

**List result shape:**

| Field | Type | Description |
| --- | --- | --- |
| `data` | `ContentEntryListItem[] \| null` | Array of entries, or `null` on error |
| `error` | `Error \| null` | Error object if the request failed, otherwise `null` |
| `total` | `number` | Total matching entries across all pages |
| `hasMore` | `boolean` | Whether more pages exist beyond the current page |

## Listing Entries

Chain methods to build your query, then `await` to fetch.

```typescript
// All published entries, newest first
const { data: posts, total } = await client
  .from("blog-posts")
  .eq("status", "published")
  .order("publishedAt", { ascending: false });
```

### Filtering by Status

Use `.eq("status", value)` to filter by entry status:

```typescript
// Only published entries
const { data: published } = await client
  .from("blog-posts")
  .eq("status", "published");

// Only drafts
const { data: drafts } = await client
  .from("blog-posts")
  .eq("status", "draft");

// Archived entries
const { data: archived } = await client
  .from("blog-posts")
  .eq("status", "archived");
```

### Filtering by Custom Field

Use `.filter(field, value)` to filter by any custom field defined on the model:

```typescript
// Entries where "category" custom field equals "engineering"
const { data: engineering } = await client
  .from("blog-posts")
  .eq("status", "published")
  .filter("category", "engineering");
```

### Full-Text Search

Use `.search(term)` to search entry titles:

```typescript
const { data: results } = await client
  .from("blog-posts")
  .search("kubernetes");
```

## Sorting

Use `.order(field, options?)` to control sort order. The `field` must be one of `"publishedAt"`, `"createdAt"`, `"updatedAt"`, or `"title"`.

```typescript
// Newest published first (default)
await client.from("blog-posts").order("publishedAt", { ascending: false });

// Oldest created first
await client.from("blog-posts").order("createdAt", { ascending: true });

// Alphabetical by title
await client.from("blog-posts").order("title", { ascending: true });
```

## Pagination

Use `.limit(n)` to set entries per page and `.page(n)` to select the page (1-based).

```typescript
// First page, 10 entries
const { data, total, hasMore } = await client
  .from("blog-posts")
  .eq("status", "published")
  .limit(10)
  .page(1);
```

**Pagination loop:**

```typescript
let page = 1;
let hasMore = true;

while (hasMore) {
  const result = await client
    .from("blog-posts")
    .eq("status", "published")
    .limit(20)
    .page(page);

  console.log(`Page ${page}: ${result.data?.length} entries (${result.total} total)`);
  hasMore = result.hasMore;
  page++;
}
```

## Field Selection

Use `.select(...fields)` to request only specific fields. When omitted, all fields are returned. `slug` and `publishedAt` are always included.

```typescript
// Only slug, title, and publishedAt (faster, less data)
const { data } = await client
  .from("blog-posts")
  .select("title")
  .eq("status", "published");

// Include body for excerpt previews and custom fields by name
const { data } = await client
  .from("blog-posts")
  .select("title", "body", "category");
```

## Single Entry

Use `.single(slug)` to fetch a full entry by slug. This returns a `SingleQueryBuilder` which is also thenable — `await` it directly.

```typescript
const { data: post, error } = await client
  .from("blog-posts")
  .single("hello-world");
```

**Single result shape:**

| Field | Type | Description |
| --- | --- | --- |
| `data` | `ContentEntry \| null` | The entry, or `null` if not found or on error |
| `error` | `Error \| null` | Error object if the request failed, otherwise `null` |

**Response:**

```json
{
  "id": "entry-uuid",
  "slug": "hello-world",
  "status": "published",
  "publishedAt": "2026-01-15T10:00:00Z",
  "sourceLanguage": "en",
  "availableLanguages": ["en", "tr", "de"],
  "title": "Hello World",
  "body": "## Welcome\n\nWelcome to our blog...",
  "category": "Engineering",
  "readingTime": "5 min"
}
```

The `body` field is always a **Markdown string**. Use a Markdown renderer like `react-markdown` or `marked` to display it.

## Custom Fields

Content models can define custom fields beyond the base fields (title, slug, body). Custom field values are **spread directly onto the entry object** — there is no nested `customFields` wrapper.

```typescript
const { data: post } = await client
  .from("blog-posts")
  .single("hello-world");

// Access custom fields directly on the entry
console.log(post.readingTime); // "5 min"
console.log(post.category);    // "Engineering"
```

List items also return custom fields flat:

```json
{
  "slug": "hello-world",
  "title": "Hello World",
  "publishedAt": "2026-01-15T10:00:00Z",
  "category": "Engineering",
  "readingTime": "5 min"
}
```

<Callout type="tip">
  For type-safe access to custom fields, see the [TypeScript guide](/sdk/typescript).
</Callout>

## Relations

Content entries can reference entries from other models using relation fields. Use `.expand(...fields)` to resolve these references inline — without a second fetch.

```typescript
const { data: posts } = await client
  .from("blog-posts")
  .eq("status", "published")
  .expand("author", "category");
```

When `expand` is used, a `relations` key appears on each entry with the resolved data. The relation object's own custom fields are also **flat** — no nested `customFields` wrapper:

```json
{
  "slug": "hello-world",
  "title": "Hello World",
  "publishedAt": "2026-01-15T10:00:00Z",
  "category": "Engineering",
  "readingTime": "5 min",
  "relations": {
    "author": {
      "id": "user-uuid",
      "slug": "alice-johnson",
      "title": "Alice Johnson",
      "modelSlug": "users",
      "avatar": "https://cdn.example.com/avatars/alice.jpg",
      "role": "Engineering"
    },
    "category": {
      "id": "cat-uuid",
      "slug": "engineering",
      "title": "Engineering",
      "modelSlug": "categories"
    }
  }
}
```

Access relation fields directly:

```typescript
const post = posts[0];

post.relations?.author?.title;   // "Alice Johnson"
post.relations?.author?.avatar;  // "https://cdn.example.com/avatars/alice.jpg"
post.relations?.category?.title; // "Engineering"
```

`.expand()` works the same way on single entry queries:

```typescript
const { data: post } = await client
  .from("blog-posts")
  .expand("author")
  .single("hello-world");

post.relations?.author?.title; // "Alice Johnson"
```

<Callout type="info">
  If a relation field has no value, its key will be `null` in `relations`.
  `expand` only fetches fields that are actually set — unreferenced fields are omitted.
</Callout>

## Language

Use `.language(code)` to request localized content in a specific language.

```typescript
const { data: post } = await client
  .from("blog-posts")
  .language("fr")
  .single("hello-world");
```

**Language fallback behavior:**

When you request a language that does not have a translation, the SDK falls back to the source language automatically:

```typescript
// If "ja" translation doesn't exist, returns "en" (source) content
const { data: post } = await client
  .from("blog-posts")
  .language("ja")
  .single("hello-world");

// post.title → English title (fallback)
```

Check `availableLanguages` on a full entry to see which translations exist before requesting a specific language.

## Error Handling

Every query returns `{ data, error }`. Check `error` before using `data`:

```typescript
const { data: post, error } = await client
  .from("blog-posts")
  .single("hello-world");

if (error) {
  console.error("Failed to fetch post:", error.message);
  return null;
}

// data is safe to use here
console.log(post.title);
```

For list queries:

```typescript
const { data: posts, error, total } = await client
  .from("blog-posts")
  .eq("status", "published");

if (error) {
  console.error("Failed to fetch posts:", error.message);
  return [];
}

console.log(`Fetched ${posts.length} of ${total} posts`);
```

## Legacy API

The `getEntries()` and `getEntry()` methods still work but are deprecated. Use `from()` for all new code. For a complete list of deprecated signatures, see the [API reference](/sdk/api-reference#legacy-methods).
