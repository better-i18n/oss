---
title: Setup
description: Installation and configuration for Expo and React Native
---

# Setup

This guide walks you through installing `@better-i18n/expo` and setting up i18next in your Expo or React Native app.

<Callout type="info">
**Prerequisite:** Create a project at [dash.better-i18n.com](https://dash.better-i18n.com). Your project identifier will be in the format `org/project` (e.g., `my-company/mobile-app`).
</Callout>

## Installation

<Tabs items={['npm', 'yarn', 'pnpm', 'bun']}>
  <Tab value="npm">
  ```bash
  npm install @better-i18n/expo i18next react-i18next
  ```
  </Tab>
  <Tab value="yarn">
  ```bash
  yarn add @better-i18n/expo i18next react-i18next
  ```
  </Tab>
  <Tab value="pnpm">
  ```bash
  pnpm add @better-i18n/expo i18next react-i18next
  ```
  </Tab>
  <Tab value="bun">
  ```bash
  bun add @better-i18n/expo i18next react-i18next
  ```
  </Tab>
</Tabs>

### Recommended Optional Dependencies

For offline caching and device locale detection:

```bash
npx expo install react-native-mmkv expo-localization
```

- **react-native-mmkv** - Fastest persistent storage for offline caching (auto-detected)
- **expo-localization** - Enables device locale detection via `useDeviceLocale`

<Callout type="tip">
  Both are optional. Storage is auto-detected at runtime: MMKV → AsyncStorage → in-memory.
</Callout>

## Configuration

<Steps>

<Step>
### Create i18n Config

Create a file to initialize i18next with `initBetterI18n`:

```ts title="src/i18n.ts"
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import { initBetterI18n } from '@better-i18n/expo';

i18n.use(initReactI18next);

// Start at module level — the promise is cached, so multiple imports won't re-run init
export const i18nReady = initBetterI18n({
  project: 'your-org/your-project',
  i18n,
  defaultLocale: 'en',
  debug: __DEV__,
});

export { i18n };
```

<Callout type="tip">
  Need the language list? Access it directly from the resolved promise: `const { languages } = await i18nReady`. No wrapper functions or mutable module-level variables needed.
</Callout>
</Step>

<Step>
### Initialize in App Entry

Await `i18nReady` before rendering your app. Use `SplashScreen` to keep the native splash visible during init — the user sees no loading indicator at all.

<Tabs items={['Expo', 'Bare React Native']}>
  <Tab value="Expo">
```tsx title="App.tsx"
import { useEffect, useState } from 'react';
import * as SplashScreen from 'expo-splash-screen';
import { i18nReady } from './src/i18n';
import { HomeScreen } from './src/screens/HomeScreen';

// Hold the splash screen until the app is ready
SplashScreen.preventAutoHideAsync();

export default function App() {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    i18nReady.then(() => {
      setReady(true);
      SplashScreen.hideAsync();
    });
  }, []);

  // SplashScreen is visible, so the user sees nothing during init
  if (!ready) return null;

  return <HomeScreen />;
}
```

<Callout type="info">
  `SplashScreen.preventAutoHideAsync()` is called at module level (outside the component) so it takes effect before the first render. The native splash stays visible while `i18nReady` resolves — no spinner, no blank screen.
</Callout>
  </Tab>
  <Tab value="Bare React Native">
```ts title="index.ts"
import { registerRootComponent } from 'expo';
import { i18nReady } from './src/i18n';

// The App component is only mounted after i18n is ready — no loading state needed
i18nReady.then(() => {
  const { App } = require('./src/App');
  registerRootComponent(App);
});
```

<Callout type="warning">
  This pattern only works in the bare workflow. For Expo Router, use the SplashScreen approach in `app/_layout.tsx` instead — see the [Expo Router Integration](#expo-router-integration) section below.
</Callout>
  </Tab>
</Tabs>
</Step>

<Step>
### Use Translations

Use the standard `react-i18next` hooks — no changes to your components:

```tsx title="src/screens/HomeScreen.tsx"
import { useTranslation } from 'react-i18next';
import { Text, View } from 'react-native';

export function HomeScreen() {
  const { t } = useTranslation();

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text style={{ fontSize: 24 }}>{t('welcome')}</Text>
      <Text>{t('description')}</Text>
    </View>
  );
}
```
</Step>

</Steps>

## Expo Router Integration

For production Expo apps using **Expo Router**, the pattern above can be extended into a clean, modular architecture that eliminates the "English flash" problem and integrates with `SplashScreen`.

<Callout type="tip">
  **What is the English flash?** When you hardcode `defaultLocale: 'en'`, the app always initializes in English — even if the user had previously selected Turkish. For one frame, translated UI renders in English before switching. Reading the persisted locale from storage and passing it as `defaultLocale` eliminates this entirely.
</Callout>

### File Structure

```
lib/
  i18n/
    config.ts   ← i18next instance + MMKV storage adapter + initializeI18nBackend
    index.ts    ← initializeI18n (reads stored locale, handles fallback)
  context/
    LanguageContext.tsx  ← React context + useLanguage hook
app/
  _layout.tsx   ← LanguageProvider wrapping + SplashScreen gate
```

### `lib/i18n/config.ts` — Backend Initialization

```ts title="lib/i18n/config.ts"
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import { initBetterI18n } from '@better-i18n/expo';
import type { BetterI18nResult } from '@better-i18n/expo';
import { storage } from '../storage'; // your MMKV instance

// Use your app's existing MMKV instance — no extra storage created
const mmkvStorage = {
  getItem: async (key: string) => storage.getString(key) ?? null,
  setItem: async (key: string, value: string) => { storage.set(key, value); },
  removeItem: async (key: string) => { storage.remove(key); },
};

i18n.use(initReactI18next);

let result: BetterI18nResult | null = null;

export async function initializeI18nBackend(locale: string = 'en'): Promise<void> {
  if (result) return; // singleton guard

  result = await initBetterI18n({
    project: 'your-org/your-project',
    i18n,
    defaultLocale: locale,  // CDN fetches this locale on first init
    storage: mmkvStorage,
    debug: __DEV__,
    i18nextOptions: { fallbackLng: 'en' },
  });
}

export function getManifestLanguages() { return result?.languages ?? []; }
export function getSupportedLanguageCodes() { return result?.languages.map(l => l.code) ?? []; }
export function resetI18nSingleton() { result = null; }
export default i18n;
```

### `lib/i18n/index.ts` — Locale Resolution

```ts title="lib/i18n/index.ts"
import AsyncStorage from '@react-native-async-storage/async-storage';
import i18n, { initializeI18nBackend, getManifestLanguages } from './config';

const LANGUAGE_KEY = 'app_language';

export async function initializeI18n(): Promise<string> {
  // Read persisted locale — this is the key to eliminating English flash
  const storedLocale = await AsyncStorage.getItem(LANGUAGE_KEY);
  const initialLocale = storedLocale || 'en';

  try {
    // Initialize backend with stored locale so CDN fetches the right language
    await initializeI18nBackend(initialLocale);
  } catch {
    // CDN down, no cache — fall back to English
    console.warn(`[i18n] Failed to init with '${initialLocale}', falling back to 'en'`);
    await initializeI18nBackend('en');
    return 'en';
  }

  return initialLocale;
}

export async function setLanguage(language: string): Promise<void> {
  await AsyncStorage.setItem(LANGUAGE_KEY, language);
  await i18n.changeLanguage(language);
}

export function subscribeToLanguageChanges(listener: (lang: string) => void) {
  i18n.on('languageChanged', listener);
  return () => i18n.off('languageChanged', listener);
}

export { getManifestLanguages };
export { i18n };
```

### `lib/context/LanguageContext.tsx` — React Context

```tsx title="lib/context/LanguageContext.tsx"
import React, { createContext, useContext, useEffect, useState } from 'react';
import {
  initializeI18n,
  setLanguage as setI18nLanguage,
  subscribeToLanguageChanges,
  getManifestLanguages,
} from '../i18n';

interface LanguageContextType {
  currentLanguage: string;
  isInitialized: boolean;
  setLanguage: (lang: string) => Promise<void>;
  supportedLanguages: ReturnType<typeof getManifestLanguages>;
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [currentLanguage, setCurrentLanguage] = useState('en');
  const [isInitialized, setIsInitialized] = useState(false);
  const [supportedLanguages, setSupportedLanguages] = useState<ReturnType<typeof getManifestLanguages>>([]);

  useEffect(() => {
    initializeI18n()
      .then((lang) => {
        setCurrentLanguage(lang);
        setSupportedLanguages(getManifestLanguages());
      })
      .catch(() => setCurrentLanguage('en'))
      .finally(() => setIsInitialized(true));

    // Reactive updates when language changes (e.g., from LanguagePicker)
    return subscribeToLanguageChanges(setCurrentLanguage);
  }, []);

  return (
    <LanguageContext.Provider value={{
      currentLanguage,
      isInitialized,
      setLanguage: setI18nLanguage,
      supportedLanguages,
    }}>
      {children}
    </LanguageContext.Provider>
  );
}

export function useLanguage() {
  const ctx = useContext(LanguageContext);
  if (!ctx) throw new Error('useLanguage must be used within LanguageProvider');
  return ctx;
}
```

### `app/_layout.tsx` — SplashScreen Gate

```tsx title="app/_layout.tsx"
import * as SplashScreen from 'expo-splash-screen';
import { Stack } from 'expo-router';
import { LanguageProvider } from '~/lib/context/LanguageContext';
import { useLanguage } from '~/lib/context/LanguageContext';
import React from 'react';

// Keep splash visible until we're ready
SplashScreen.preventAutoHideAsync();

function AppContent() {
  const { isInitialized } = useLanguage();

  React.useEffect(() => {
    if (isInitialized) {
      SplashScreen.hideAsync();
    }
  }, [isInitialized]);

  // Don't render navigation until i18n is ready — no English flash
  if (!isInitialized) return null;

  return <Stack />;
}

export default function RootLayout() {
  return (
    <LanguageProvider>
      <AppContent />
    </LanguageProvider>
  );
}
```

<Callout type="info">
  The `isInitialized` gate is what prevents English flash: navigation only renders after `initializeI18n()` resolves with the correct locale. SplashScreen stays visible during this window.
</Callout>

## Language Switching

Use `i18n.changeLanguage()` to switch languages at runtime. Translations are **pre-loaded before the switch** — no loading spinners or English flash.

```tsx title="src/components/LanguagePicker.tsx"
import { useTranslation } from 'react-i18next';
import { FlatList, Pressable, Text } from 'react-native';
import { getLanguages } from '../i18n';

export function LanguagePicker() {
  const { i18n } = useTranslation();
  const languages = getLanguages();

  return (
    <FlatList
      data={languages}
      keyExtractor={(item) => item.code}
      renderItem={({ item }) => (
        <Pressable onPress={() => i18n.changeLanguage(item.code)}>
          <Text>{item.nativeName ?? item.name}</Text>
        </Pressable>
      )}
    />
  );
}
```

<Callout type="tip">
  Language switching is instant — `initBetterI18n` overrides `changeLanguage()` to pre-load translations from CDN (or cache) before the switch happens. No loading spinners or English flash.
</Callout>

## Options

All options are passed to `initBetterI18n`:

```ts
await initBetterI18n({
  project: 'your-org/your-project',  // Required
  i18n,                               // Required
  defaultLocale: 'en',
  storage: customStorage,
  staticData: { en: { common: { welcome: 'Welcome' } } },
  fetchTimeout: 10000,
  retryCount: 1,
  useDeviceLocale: true,
  debug: __DEV__,
  i18nextOptions: { defaultNS: 'common' },
});
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `project` | `string` | Required | Project identifier (`org/project`) |
| `i18n` | `i18n` | Required | i18next instance (call `.use(initReactI18next)` first) |
| `defaultLocale` | `string` | `"en"` | Fallback locale |
| `storage` | `TranslationStorage` | Auto-detected | MMKV → AsyncStorage → in-memory |
| `staticData` | `Record<string, Messages>` | — | Bundled fallback for airplane mode first launch. Optional — not needed if you use MMKV or AsyncStorage. See [Offline & Caching](/frameworks/expo/offline-caching). |
| `fetchTimeout` | `number` | `10000` | CDN fetch timeout (ms) |
| `retryCount` | `number` | `1` | Retry attempts on CDN failure |
| `useDeviceLocale` | `boolean` | `false` | Auto-detect device locale |
| `debug` | `boolean` | `false` | Enable debug logging |
| `i18nextOptions` | `Partial<InitOptions>` | `{}` | Extra i18next init options |

<Callout type="warning">
  Do **not** call `i18n.init()` separately when using `initBetterI18n` — it already calls `init()` internally. Pass your options via `i18nextOptions` to avoid double initialization.
</Callout>

## Next Steps

<Cards>
  <Card title="Offline & Caching" icon="WifiOff" href="/frameworks/expo/offline-caching">
    Understand the caching strategy and offline support.
  </Card>
  <Card title="API Reference" icon="FileCode" href="/frameworks/expo/api-reference">
    Full API documentation for all exports.
  </Card>
</Cards>
